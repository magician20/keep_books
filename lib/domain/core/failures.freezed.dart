// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'failures.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$ValueFailure<T> {
  T? get failedValue => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $ValueFailureCopyWith<T, ValueFailure<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ValueFailureCopyWith<T, $Res> {
  factory $ValueFailureCopyWith(
          ValueFailure<T> value, $Res Function(ValueFailure<T>) then) =
      _$ValueFailureCopyWithImpl<T, $Res>;
  $Res call({T? failedValue});
}

/// @nodoc
class _$ValueFailureCopyWithImpl<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  _$ValueFailureCopyWithImpl(this._value, this._then);

  final ValueFailure<T> _value;
  // ignore: unused_field
  final $Res Function(ValueFailure<T>) _then;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_value.copyWith(
      failedValue: failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc
abstract class _$$InvalidEmailCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$InvalidEmailCopyWith(
          _$InvalidEmail<T> value, $Res Function(_$InvalidEmail<T>) then) =
      __$$InvalidEmailCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$InvalidEmailCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$InvalidEmailCopyWith<T, $Res> {
  __$$InvalidEmailCopyWithImpl(
      _$InvalidEmail<T> _value, $Res Function(_$InvalidEmail<T>) _then)
      : super(_value, (v) => _then(v as _$InvalidEmail<T>));

  @override
  _$InvalidEmail<T> get _value => super._value as _$InvalidEmail<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidEmail<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$InvalidEmail<T> implements InvalidEmail<T> {
  const _$InvalidEmail(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidEmail(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidEmail<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$InvalidEmailCopyWith<T, _$InvalidEmail<T>> get copyWith =>
      __$$InvalidEmailCopyWithImpl<T, _$InvalidEmail<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return invalidEmail(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return invalidEmail?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return invalidEmail(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return invalidEmail?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (invalidEmail != null) {
      return invalidEmail(this);
    }
    return orElse();
  }
}

abstract class InvalidEmail<T> implements ValueFailure<T> {
  const factory InvalidEmail(final T? failedValue) = _$InvalidEmail<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$InvalidEmailCopyWith<T, _$InvalidEmail<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidUserNameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$InvalidUserNameCopyWith(_$InvalidUserName<T> value,
          $Res Function(_$InvalidUserName<T>) then) =
      __$$InvalidUserNameCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$InvalidUserNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$InvalidUserNameCopyWith<T, $Res> {
  __$$InvalidUserNameCopyWithImpl(
      _$InvalidUserName<T> _value, $Res Function(_$InvalidUserName<T>) _then)
      : super(_value, (v) => _then(v as _$InvalidUserName<T>));

  @override
  _$InvalidUserName<T> get _value => super._value as _$InvalidUserName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidUserName<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$InvalidUserName<T> implements InvalidUserName<T> {
  const _$InvalidUserName(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidNameAlphabet(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidUserName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$InvalidUserNameCopyWith<T, _$InvalidUserName<T>> get copyWith =>
      __$$InvalidUserNameCopyWithImpl<T, _$InvalidUserName<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return invalidNameAlphabet(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return invalidNameAlphabet?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (invalidNameAlphabet != null) {
      return invalidNameAlphabet(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return invalidNameAlphabet(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return invalidNameAlphabet?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (invalidNameAlphabet != null) {
      return invalidNameAlphabet(this);
    }
    return orElse();
  }
}

abstract class InvalidUserName<T> implements ValueFailure<T> {
  const factory InvalidUserName(final T? failedValue) = _$InvalidUserName<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$InvalidUserNameCopyWith<T, _$InvalidUserName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ShortPasswordCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$ShortPasswordCopyWith(
          _$ShortPassword<T> value, $Res Function(_$ShortPassword<T>) then) =
      __$$ShortPasswordCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue, int? min});
}

/// @nodoc
class __$$ShortPasswordCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$ShortPasswordCopyWith<T, $Res> {
  __$$ShortPasswordCopyWithImpl(
      _$ShortPassword<T> _value, $Res Function(_$ShortPassword<T>) _then)
      : super(_value, (v) => _then(v as _$ShortPassword<T>));

  @override
  _$ShortPassword<T> get _value => super._value as _$ShortPassword<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? min = freezed,
  }) {
    return _then(_$ShortPassword<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
      min: min == freezed
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ShortPassword<T> implements ShortPassword<T> {
  const _$ShortPassword(this.failedValue, {this.min});

  @override
  final T? failedValue;
  @override
  final int? min;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortPassword(failedValue: $failedValue, min: $min)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShortPassword<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            const DeepCollectionEquality().equals(other.min, min));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(failedValue),
      const DeepCollectionEquality().hash(min));

  @JsonKey(ignore: true)
  @override
  _$$ShortPasswordCopyWith<T, _$ShortPassword<T>> get copyWith =>
      __$$ShortPasswordCopyWithImpl<T, _$ShortPassword<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return shortPassword(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return shortPassword?.call(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(failedValue, min);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return shortPassword(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return shortPassword?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (shortPassword != null) {
      return shortPassword(this);
    }
    return orElse();
  }
}

abstract class ShortPassword<T> implements ValueFailure<T> {
  const factory ShortPassword(final T? failedValue, {final int? min}) =
      _$ShortPassword<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  int? get min => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ShortPasswordCopyWith<T, _$ShortPassword<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ShortUserNameCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$ShortUserNameCopyWith(
          _$ShortUserName<T> value, $Res Function(_$ShortUserName<T>) then) =
      __$$ShortUserNameCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue, int? min});
}

/// @nodoc
class __$$ShortUserNameCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$ShortUserNameCopyWith<T, $Res> {
  __$$ShortUserNameCopyWithImpl(
      _$ShortUserName<T> _value, $Res Function(_$ShortUserName<T>) _then)
      : super(_value, (v) => _then(v as _$ShortUserName<T>));

  @override
  _$ShortUserName<T> get _value => super._value as _$ShortUserName<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? min = freezed,
  }) {
    return _then(_$ShortUserName<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
      min: min == freezed
          ? _value.min
          : min // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ShortUserName<T> implements ShortUserName<T> {
  const _$ShortUserName(this.failedValue, {this.min});

  @override
  final T? failedValue;
  @override
  final int? min;

  @override
  String toString() {
    return 'ValueFailure<$T>.shortUserName(failedValue: $failedValue, min: $min)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ShortUserName<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            const DeepCollectionEquality().equals(other.min, min));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(failedValue),
      const DeepCollectionEquality().hash(min));

  @JsonKey(ignore: true)
  @override
  _$$ShortUserNameCopyWith<T, _$ShortUserName<T>> get copyWith =>
      __$$ShortUserNameCopyWithImpl<T, _$ShortUserName<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return shortUserName(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return shortUserName?.call(failedValue, min);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (shortUserName != null) {
      return shortUserName(failedValue, min);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return shortUserName(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return shortUserName?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (shortUserName != null) {
      return shortUserName(this);
    }
    return orElse();
  }
}

abstract class ShortUserName<T> implements ValueFailure<T> {
  const factory ShortUserName(final T? failedValue, {final int? min}) =
      _$ShortUserName<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  int? get min => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ShortUserNameCopyWith<T, _$ShortUserName<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MultilineCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$MultilineCopyWith(
          _$Multiline<T> value, $Res Function(_$Multiline<T>) then) =
      __$$MultilineCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$MultilineCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$MultilineCopyWith<T, $Res> {
  __$$MultilineCopyWithImpl(
      _$Multiline<T> _value, $Res Function(_$Multiline<T>) _then)
      : super(_value, (v) => _then(v as _$Multiline<T>));

  @override
  _$Multiline<T> get _value => super._value as _$Multiline<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$Multiline<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$Multiline<T> implements Multiline<T> {
  const _$Multiline(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.multiline(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Multiline<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$MultilineCopyWith<T, _$Multiline<T>> get copyWith =>
      __$$MultilineCopyWithImpl<T, _$Multiline<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return multiline(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return multiline?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return multiline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return multiline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (multiline != null) {
      return multiline(this);
    }
    return orElse();
  }
}

abstract class Multiline<T> implements ValueFailure<T> {
  const factory Multiline(final T? failedValue) = _$Multiline<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$MultilineCopyWith<T, _$Multiline<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ListTooLongCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$ListTooLongCopyWith(
          _$ListTooLong<T> value, $Res Function(_$ListTooLong<T>) then) =
      __$$ListTooLongCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue, int? max});
}

/// @nodoc
class __$$ListTooLongCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$ListTooLongCopyWith<T, $Res> {
  __$$ListTooLongCopyWithImpl(
      _$ListTooLong<T> _value, $Res Function(_$ListTooLong<T>) _then)
      : super(_value, (v) => _then(v as _$ListTooLong<T>));

  @override
  _$ListTooLong<T> get _value => super._value as _$ListTooLong<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? max = freezed,
  }) {
    return _then(_$ListTooLong<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ListTooLong<T> implements ListTooLong<T> {
  const _$ListTooLong(this.failedValue, {this.max});

  @override
  final T? failedValue;
  @override
  final int? max;

  @override
  String toString() {
    return 'ValueFailure<$T>.listTooLong(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListTooLong<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            const DeepCollectionEquality().equals(other.max, max));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(failedValue),
      const DeepCollectionEquality().hash(max));

  @JsonKey(ignore: true)
  @override
  _$$ListTooLongCopyWith<T, _$ListTooLong<T>> get copyWith =>
      __$$ListTooLongCopyWithImpl<T, _$ListTooLong<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return listTooLong(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return listTooLong?.call(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (listTooLong != null) {
      return listTooLong(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return listTooLong(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return listTooLong?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (listTooLong != null) {
      return listTooLong(this);
    }
    return orElse();
  }
}

abstract class ListTooLong<T> implements ValueFailure<T> {
  const factory ListTooLong(final T? failedValue, {final int? max}) =
      _$ListTooLong<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  int? get max => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ListTooLongCopyWith<T, _$ListTooLong<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ExceedingLengthCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$ExceedingLengthCopyWith(_$ExceedingLength<T> value,
          $Res Function(_$ExceedingLength<T>) then) =
      __$$ExceedingLengthCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue, int? max});
}

/// @nodoc
class __$$ExceedingLengthCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$ExceedingLengthCopyWith<T, $Res> {
  __$$ExceedingLengthCopyWithImpl(
      _$ExceedingLength<T> _value, $Res Function(_$ExceedingLength<T>) _then)
      : super(_value, (v) => _then(v as _$ExceedingLength<T>));

  @override
  _$ExceedingLength<T> get _value => super._value as _$ExceedingLength<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
    Object? max = freezed,
  }) {
    return _then(_$ExceedingLength<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
      max: max == freezed
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as int?,
    ));
  }
}

/// @nodoc

class _$ExceedingLength<T> implements ExceedingLength<T> {
  const _$ExceedingLength(this.failedValue, {this.max});

  @override
  final T? failedValue;
  @override
  final int? max;

  @override
  String toString() {
    return 'ValueFailure<$T>.exceedingLength(failedValue: $failedValue, max: $max)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExceedingLength<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue) &&
            const DeepCollectionEquality().equals(other.max, max));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(failedValue),
      const DeepCollectionEquality().hash(max));

  @JsonKey(ignore: true)
  @override
  _$$ExceedingLengthCopyWith<T, _$ExceedingLength<T>> get copyWith =>
      __$$ExceedingLengthCopyWithImpl<T, _$ExceedingLength<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return exceedingLength(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return exceedingLength?.call(failedValue, max);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(failedValue, max);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return exceedingLength(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return exceedingLength?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (exceedingLength != null) {
      return exceedingLength(this);
    }
    return orElse();
  }
}

abstract class ExceedingLength<T> implements ValueFailure<T> {
  const factory ExceedingLength(final T? failedValue, {final int? max}) =
      _$ExceedingLength<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  int? get max => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$ExceedingLengthCopyWith<T, _$ExceedingLength<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$EmptyCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$EmptyCopyWith(_$Empty<T> value, $Res Function(_$Empty<T>) then) =
      __$$EmptyCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$EmptyCopyWithImpl<T, $Res> extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$EmptyCopyWith<T, $Res> {
  __$$EmptyCopyWithImpl(_$Empty<T> _value, $Res Function(_$Empty<T>) _then)
      : super(_value, (v) => _then(v as _$Empty<T>));

  @override
  _$Empty<T> get _value => super._value as _$Empty<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$Empty<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$Empty<T> implements Empty<T> {
  const _$Empty(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.empty(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$Empty<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$EmptyCopyWith<T, _$Empty<T>> get copyWith =>
      __$$EmptyCopyWithImpl<T, _$Empty<T>>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return empty(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return empty?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class Empty<T> implements ValueFailure<T> {
  const factory Empty(final T? failedValue) = _$Empty<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$EmptyCopyWith<T, _$Empty<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AtLeastOneUpperCharCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$AtLeastOneUpperCharCopyWith(_$AtLeastOneUpperChar<T> value,
          $Res Function(_$AtLeastOneUpperChar<T>) then) =
      __$$AtLeastOneUpperCharCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$AtLeastOneUpperCharCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$AtLeastOneUpperCharCopyWith<T, $Res> {
  __$$AtLeastOneUpperCharCopyWithImpl(_$AtLeastOneUpperChar<T> _value,
      $Res Function(_$AtLeastOneUpperChar<T>) _then)
      : super(_value, (v) => _then(v as _$AtLeastOneUpperChar<T>));

  @override
  _$AtLeastOneUpperChar<T> get _value =>
      super._value as _$AtLeastOneUpperChar<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$AtLeastOneUpperChar<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$AtLeastOneUpperChar<T> implements AtLeastOneUpperChar<T> {
  const _$AtLeastOneUpperChar(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.atLeastOneUpperChar(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AtLeastOneUpperChar<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$AtLeastOneUpperCharCopyWith<T, _$AtLeastOneUpperChar<T>> get copyWith =>
      __$$AtLeastOneUpperCharCopyWithImpl<T, _$AtLeastOneUpperChar<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return atLeastOneUpperChar(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return atLeastOneUpperChar?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (atLeastOneUpperChar != null) {
      return atLeastOneUpperChar(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return atLeastOneUpperChar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return atLeastOneUpperChar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (atLeastOneUpperChar != null) {
      return atLeastOneUpperChar(this);
    }
    return orElse();
  }
}

abstract class AtLeastOneUpperChar<T> implements ValueFailure<T> {
  const factory AtLeastOneUpperChar(final T? failedValue) =
      _$AtLeastOneUpperChar<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$AtLeastOneUpperCharCopyWith<T, _$AtLeastOneUpperChar<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AtLeastOneLowerCharCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$AtLeastOneLowerCharCopyWith(_$AtLeastOneLowerChar<T> value,
          $Res Function(_$AtLeastOneLowerChar<T>) then) =
      __$$AtLeastOneLowerCharCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$AtLeastOneLowerCharCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$AtLeastOneLowerCharCopyWith<T, $Res> {
  __$$AtLeastOneLowerCharCopyWithImpl(_$AtLeastOneLowerChar<T> _value,
      $Res Function(_$AtLeastOneLowerChar<T>) _then)
      : super(_value, (v) => _then(v as _$AtLeastOneLowerChar<T>));

  @override
  _$AtLeastOneLowerChar<T> get _value =>
      super._value as _$AtLeastOneLowerChar<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$AtLeastOneLowerChar<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$AtLeastOneLowerChar<T> implements AtLeastOneLowerChar<T> {
  const _$AtLeastOneLowerChar(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.atLeastOneLowerChar(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AtLeastOneLowerChar<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$AtLeastOneLowerCharCopyWith<T, _$AtLeastOneLowerChar<T>> get copyWith =>
      __$$AtLeastOneLowerCharCopyWithImpl<T, _$AtLeastOneLowerChar<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return atLeastOneLowerChar(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return atLeastOneLowerChar?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (atLeastOneLowerChar != null) {
      return atLeastOneLowerChar(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return atLeastOneLowerChar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return atLeastOneLowerChar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (atLeastOneLowerChar != null) {
      return atLeastOneLowerChar(this);
    }
    return orElse();
  }
}

abstract class AtLeastOneLowerChar<T> implements ValueFailure<T> {
  const factory AtLeastOneLowerChar(final T? failedValue) =
      _$AtLeastOneLowerChar<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$AtLeastOneLowerCharCopyWith<T, _$AtLeastOneLowerChar<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AtLeastOneDigitCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$AtLeastOneDigitCopyWith(_$AtLeastOneDigit<T> value,
          $Res Function(_$AtLeastOneDigit<T>) then) =
      __$$AtLeastOneDigitCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$AtLeastOneDigitCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$AtLeastOneDigitCopyWith<T, $Res> {
  __$$AtLeastOneDigitCopyWithImpl(
      _$AtLeastOneDigit<T> _value, $Res Function(_$AtLeastOneDigit<T>) _then)
      : super(_value, (v) => _then(v as _$AtLeastOneDigit<T>));

  @override
  _$AtLeastOneDigit<T> get _value => super._value as _$AtLeastOneDigit<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$AtLeastOneDigit<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$AtLeastOneDigit<T> implements AtLeastOneDigit<T> {
  const _$AtLeastOneDigit(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.atLeastOneDigit(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AtLeastOneDigit<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$AtLeastOneDigitCopyWith<T, _$AtLeastOneDigit<T>> get copyWith =>
      __$$AtLeastOneDigitCopyWithImpl<T, _$AtLeastOneDigit<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return atLeastOneDigit(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return atLeastOneDigit?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (atLeastOneDigit != null) {
      return atLeastOneDigit(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return atLeastOneDigit(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return atLeastOneDigit?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (atLeastOneDigit != null) {
      return atLeastOneDigit(this);
    }
    return orElse();
  }
}

abstract class AtLeastOneDigit<T> implements ValueFailure<T> {
  const factory AtLeastOneDigit(final T? failedValue) = _$AtLeastOneDigit<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$AtLeastOneDigitCopyWith<T, _$AtLeastOneDigit<T>> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$AtLeastOneSpecialCharCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$AtLeastOneSpecialCharCopyWith(_$AtLeastOneSpecialChar<T> value,
          $Res Function(_$AtLeastOneSpecialChar<T>) then) =
      __$$AtLeastOneSpecialCharCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$AtLeastOneSpecialCharCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$AtLeastOneSpecialCharCopyWith<T, $Res> {
  __$$AtLeastOneSpecialCharCopyWithImpl(_$AtLeastOneSpecialChar<T> _value,
      $Res Function(_$AtLeastOneSpecialChar<T>) _then)
      : super(_value, (v) => _then(v as _$AtLeastOneSpecialChar<T>));

  @override
  _$AtLeastOneSpecialChar<T> get _value =>
      super._value as _$AtLeastOneSpecialChar<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$AtLeastOneSpecialChar<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$AtLeastOneSpecialChar<T> implements AtLeastOneSpecialChar<T> {
  const _$AtLeastOneSpecialChar(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.atLeastOneSpecialChar(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AtLeastOneSpecialChar<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$AtLeastOneSpecialCharCopyWith<T, _$AtLeastOneSpecialChar<T>>
      get copyWith =>
          __$$AtLeastOneSpecialCharCopyWithImpl<T, _$AtLeastOneSpecialChar<T>>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return atLeastOneSpecialChar(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return atLeastOneSpecialChar?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (atLeastOneSpecialChar != null) {
      return atLeastOneSpecialChar(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return atLeastOneSpecialChar(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return atLeastOneSpecialChar?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (atLeastOneSpecialChar != null) {
      return atLeastOneSpecialChar(this);
    }
    return orElse();
  }
}

abstract class AtLeastOneSpecialChar<T> implements ValueFailure<T> {
  const factory AtLeastOneSpecialChar(final T? failedValue) =
      _$AtLeastOneSpecialChar<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$AtLeastOneSpecialCharCopyWith<T, _$AtLeastOneSpecialChar<T>>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$InvalidBookStatusCopyWith<T, $Res>
    implements $ValueFailureCopyWith<T, $Res> {
  factory _$$InvalidBookStatusCopyWith(_$InvalidBookStatus<T> value,
          $Res Function(_$InvalidBookStatus<T>) then) =
      __$$InvalidBookStatusCopyWithImpl<T, $Res>;
  @override
  $Res call({T? failedValue});
}

/// @nodoc
class __$$InvalidBookStatusCopyWithImpl<T, $Res>
    extends _$ValueFailureCopyWithImpl<T, $Res>
    implements _$$InvalidBookStatusCopyWith<T, $Res> {
  __$$InvalidBookStatusCopyWithImpl(_$InvalidBookStatus<T> _value,
      $Res Function(_$InvalidBookStatus<T>) _then)
      : super(_value, (v) => _then(v as _$InvalidBookStatus<T>));

  @override
  _$InvalidBookStatus<T> get _value => super._value as _$InvalidBookStatus<T>;

  @override
  $Res call({
    Object? failedValue = freezed,
  }) {
    return _then(_$InvalidBookStatus<T>(
      failedValue == freezed
          ? _value.failedValue
          : failedValue // ignore: cast_nullable_to_non_nullable
              as T?,
    ));
  }
}

/// @nodoc

class _$InvalidBookStatus<T> implements InvalidBookStatus<T> {
  const _$InvalidBookStatus(this.failedValue);

  @override
  final T? failedValue;

  @override
  String toString() {
    return 'ValueFailure<$T>.invalidBookStatus(failedValue: $failedValue)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$InvalidBookStatus<T> &&
            const DeepCollectionEquality()
                .equals(other.failedValue, failedValue));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(failedValue));

  @JsonKey(ignore: true)
  @override
  _$$InvalidBookStatusCopyWith<T, _$InvalidBookStatus<T>> get copyWith =>
      __$$InvalidBookStatusCopyWithImpl<T, _$InvalidBookStatus<T>>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(T? failedValue) invalidEmail,
    required TResult Function(T? failedValue) invalidNameAlphabet,
    required TResult Function(T? failedValue, int? min) shortPassword,
    required TResult Function(T? failedValue, int? min) shortUserName,
    required TResult Function(T? failedValue) multiline,
    required TResult Function(T? failedValue, int? max) listTooLong,
    required TResult Function(T? failedValue, int? max) exceedingLength,
    required TResult Function(T? failedValue) empty,
    required TResult Function(T? failedValue) atLeastOneUpperChar,
    required TResult Function(T? failedValue) atLeastOneLowerChar,
    required TResult Function(T? failedValue) atLeastOneDigit,
    required TResult Function(T? failedValue) atLeastOneSpecialChar,
    required TResult Function(T? failedValue) invalidBookStatus,
  }) {
    return invalidBookStatus(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
  }) {
    return invalidBookStatus?.call(failedValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(T? failedValue)? invalidEmail,
    TResult Function(T? failedValue)? invalidNameAlphabet,
    TResult Function(T? failedValue, int? min)? shortPassword,
    TResult Function(T? failedValue, int? min)? shortUserName,
    TResult Function(T? failedValue)? multiline,
    TResult Function(T? failedValue, int? max)? listTooLong,
    TResult Function(T? failedValue, int? max)? exceedingLength,
    TResult Function(T? failedValue)? empty,
    TResult Function(T? failedValue)? atLeastOneUpperChar,
    TResult Function(T? failedValue)? atLeastOneLowerChar,
    TResult Function(T? failedValue)? atLeastOneDigit,
    TResult Function(T? failedValue)? atLeastOneSpecialChar,
    TResult Function(T? failedValue)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (invalidBookStatus != null) {
      return invalidBookStatus(failedValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(InvalidEmail<T> value) invalidEmail,
    required TResult Function(InvalidUserName<T> value) invalidNameAlphabet,
    required TResult Function(ShortPassword<T> value) shortPassword,
    required TResult Function(ShortUserName<T> value) shortUserName,
    required TResult Function(Multiline<T> value) multiline,
    required TResult Function(ListTooLong<T> value) listTooLong,
    required TResult Function(ExceedingLength<T> value) exceedingLength,
    required TResult Function(Empty<T> value) empty,
    required TResult Function(AtLeastOneUpperChar<T> value) atLeastOneUpperChar,
    required TResult Function(AtLeastOneLowerChar<T> value) atLeastOneLowerChar,
    required TResult Function(AtLeastOneDigit<T> value) atLeastOneDigit,
    required TResult Function(AtLeastOneSpecialChar<T> value)
        atLeastOneSpecialChar,
    required TResult Function(InvalidBookStatus<T> value) invalidBookStatus,
  }) {
    return invalidBookStatus(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
  }) {
    return invalidBookStatus?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(InvalidEmail<T> value)? invalidEmail,
    TResult Function(InvalidUserName<T> value)? invalidNameAlphabet,
    TResult Function(ShortPassword<T> value)? shortPassword,
    TResult Function(ShortUserName<T> value)? shortUserName,
    TResult Function(Multiline<T> value)? multiline,
    TResult Function(ListTooLong<T> value)? listTooLong,
    TResult Function(ExceedingLength<T> value)? exceedingLength,
    TResult Function(Empty<T> value)? empty,
    TResult Function(AtLeastOneUpperChar<T> value)? atLeastOneUpperChar,
    TResult Function(AtLeastOneLowerChar<T> value)? atLeastOneLowerChar,
    TResult Function(AtLeastOneDigit<T> value)? atLeastOneDigit,
    TResult Function(AtLeastOneSpecialChar<T> value)? atLeastOneSpecialChar,
    TResult Function(InvalidBookStatus<T> value)? invalidBookStatus,
    required TResult orElse(),
  }) {
    if (invalidBookStatus != null) {
      return invalidBookStatus(this);
    }
    return orElse();
  }
}

abstract class InvalidBookStatus<T> implements ValueFailure<T> {
  const factory InvalidBookStatus(final T? failedValue) =
      _$InvalidBookStatus<T>;

  @override
  T? get failedValue => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$InvalidBookStatusCopyWith<T, _$InvalidBookStatus<T>> get copyWith =>
      throw _privateConstructorUsedError;
}
